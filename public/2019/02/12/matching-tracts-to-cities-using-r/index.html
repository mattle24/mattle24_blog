<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Matching Tracts to Cities using R | Blog</title>
<meta name="keywords" content="sf, spatial data, us census, tracts, dissimilarity index, r, rstats, data science" />
<meta name="description" content="This blog post is focused on how to match data from US Census tracts to US Census Places (cities) without a crosswalk table. Matching tract data to places may be useful for a variety of reasons. Recently, I wanted to measure segregation in US cities for a research project. The most commonly used metric is the dissimilarity index, which measures how much of the minority population would have to move neighborhoods in order for the overall metropolitan area to be evenely integrated.">
<meta name="author" content="Matt Lehman">
<link rel="canonical" href="https://mattle24.github.io/mattle24_blog/public/2019/02/12/matching-tracts-to-cities-using-r/" />
<link crossorigin="anonymous" href="/mattle24_blog/public/assets/css/stylesheet.min.b9ff4cc257e914dab489bd18086151800e18f91456a5174bf28489210227a659.css" integrity="sha256-uf9MwlfpFNq0ib0YCGFRgA4Y&#43;RRWpRdL8oSJIQInplk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/mattle24_blog/public/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mattle24.github.io/mattle24_blog/public/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mattle24.github.io/mattle24_blog/public/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mattle24.github.io/mattle24_blog/public/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mattle24.github.io/mattle24_blog/public/apple-touch-icon.png">
<link rel="mask-icon" href="https://mattle24.github.io/mattle24_blog/public/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Matching Tracts to Cities using R" />
<meta property="og:description" content="This blog post is focused on how to match data from US Census tracts to US Census Places (cities) without a crosswalk table. Matching tract data to places may be useful for a variety of reasons. Recently, I wanted to measure segregation in US cities for a research project. The most commonly used metric is the dissimilarity index, which measures how much of the minority population would have to move neighborhoods in order for the overall metropolitan area to be evenely integrated." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mattle24.github.io/mattle24_blog/public/2019/02/12/matching-tracts-to-cities-using-r/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-02-12T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2019-02-12T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Matching Tracts to Cities using R"/>
<meta name="twitter:description" content="This blog post is focused on how to match data from US Census tracts to US Census Places (cities) without a crosswalk table. Matching tract data to places may be useful for a variety of reasons. Recently, I wanted to measure segregation in US cities for a research project. The most commonly used metric is the dissimilarity index, which measures how much of the minority population would have to move neighborhoods in order for the overall metropolitan area to be evenely integrated."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://mattle24.github.io/mattle24_blog/public/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Matching Tracts to Cities using R",
      "item": "https://mattle24.github.io/mattle24_blog/public/2019/02/12/matching-tracts-to-cities-using-r/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Matching Tracts to Cities using R",
  "name": "Matching Tracts to Cities using R",
  "description": "This blog post is focused on how to match data from US Census tracts to US Census Places (cities) without a crosswalk table. Matching tract data to places may be useful for a variety of reasons. Recently, I wanted to measure segregation in US cities for a research project. The most commonly used metric is the dissimilarity index, which measures how much of the minority population would have to move neighborhoods in order for the overall metropolitan area to be evenely integrated.",
  "keywords": [
    "sf", "spatial data", "us census", "tracts", "dissimilarity index", "r", "rstats", "data science"
  ],
  "articleBody": " This blog post is focused on how to match data from US Census tracts to US Census Places (cities) without a crosswalk table. Matching tract data to places may be useful for a variety of reasons. Recently, I wanted to measure segregation in US cities for a research project. The most commonly used metric is the dissimilarity index, which measures how much of the minority population would have to move neighborhoods in order for the overall metropolitan area to be evenely integrated.\nHowever, the dissimilarity index requires matching sub-geomtries (neighborhoods) to macro geometries (places). I could not find any crosswalk table to link Census tracts, accepted as proxies for neighborhoods 1, to places in 1970. For a while, I wrote off the task as impratically difficult.\nAs is often the case, all it took was learning about the right package. The sf package provided me with all of the tools I needed to match tracts to places. In my research, I use data from IMPUS NHGIS, which has been an invaluable resource. However, to keep this example easily accessible, I will instead use tract data from the American Community Survey via tidycensus and place boundaries from tigris. Using tidycensus does require requesting a free API key from the US Census, which you can do here.\nPackages and setup library(sf) library(ggplot2) library(dplyr) library(tidycensus) library(tigris) library(tidyr) Sys.getenv(\"CENSUS_API_KEY\") # load API key from .Renviron options(tigris_class = \"sf\") ggplot2::theme_set(theme_bw() + theme(rect = element_blank()))  Obtain and munge data # get tract level ACS data with white and African American population ind_tracts  The tracts are in tidy format, with one row for variable B02001_002E (population white) and another row for B02001_003E (population black/ African American) but I wanted both variables in one row per tract.\nind_tracts % select(-moe) %% spread(key = variable, value = estimate) %% rename(white_pop = B02001_002, black_pop = B02001_003)  Geo-analysis To simplify the example, I isolated one city to see how tracts and places match. Since my research is focused on Indianapolis, I used that as the example. To start, I mapped Indianapolis by itself to get a sense of what to expect.\nindianapolis % filter(NAME == \"Indianapolis city (balance)\") ggplot(indianapolis) + geom_sf(color = \"darkblue\", fill = \"skyblue\") + coord_sf(datum = NA) + theme(plot.title = element_text(hjust = 0.5)) + labs(title = \"Indianapolis\") Now, let’s match the tracts. First, I tried st_covers() (a helpful sf cheatsheet is available for these functions).\n# get a matrix of one row with a logical column for each tract, TRUE if Indianapolis covers it covers_matrix  st_covers() did an okay job, but I was missing all of the tracts with any area outside of Indianapolis. Next, I tried st_intersects().\n# get a matrix of one row with a logical column for each tract, TRUE if it intersects Indianapolis intersects_matrix  st_intersects() was better, but still problematic. It picked up all of the tracts inside of Indianapolis, but also all of the tracts bordering Indianapolis. To rememedy this, I used st_intersection(). To simplify, I’m going to use the subset of the tracts defined by st_intersects() instead of the full ind_tracts.\n# get a matrix of one row with a logical column for each tract, TRUE if it intersects Indianapolis ind_tracts_intersection  ## Warning: attribute variables are assumed to be spatially constant ## throughout all geometries # map out the tracts with Indianapolis ggplot(indianapolis) + geom_sf(color = \"darkblue\", fill = \"skyblue\") + geom_sf(data = ind_tracts_intersection, color = \"yellow\", fill = \"yellow\", alpha = 0.2) + coord_sf(datum = NA) Unlike the previous two functions, st_intersection() returns an sf object. The function seems to essentially trim the tracts to make sure they are within Indianapolis. However, the new sf object contains all of the tracts as the sf object indexed by intersects_matrix, including the ones that lo longer have any significant area.\nnrow(ind_tracts_intersection) == nrow(ind_tracts[t(intersects_matrix), ]) ## [1] TRUE My hacky solution was to look at the areas. In the trimmed sf object, the borderline tracts have area approximately 0% of their original area. I confirmed this by plotting the trimmed tracts with less than 1% of their original area.\npcts   Calculating the dissimilarity index Using the percents as weights (or filtering out tracts with very small percentages), I could calculate the dissimilarity index. For Indianapolis, it does not matter if I filtered out # Calculate the disimilarity index (di) given a set of sub-geometries that match a macro-level geometry. # Eg. all the tracts in a place. dissimilarity_index % mutate( t = !!majority_pop + !!minority_pop # pop in subgeometry ,p = !!minority_pop / t # prop minority in tract ) %% summarise( T. = sum(wt * t) # total pop in macro geometry ,P. = sum(wt * !!minority_pop) / T. # prop minority in macro geometry ,dissimilarity_index = sum(wt * t * abs(p - P.)) / (2 * T. * P. * (1 - P.)) ) %% .$dissimilarity_index } ind_tracts_intersection$wt  ## [1] 0.5294555 ind_tracts_intersection$wt[ind_tracts_intersection$wt  ## [1] 0.5294455   Massey, Douglas, and Nancy Denton. 1998. American Apartheid: Segregation and the Making of the Underclass. Cambridge, MA: Harvard University Press. Google Scholar↩\n   ",
  "wordCount" : "1061",
  "inLanguage": "en",
  "datePublished": "2019-02-12T00:00:00Z",
  "dateModified": "2019-02-12T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Matt Lehman"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mattle24.github.io/mattle24_blog/public/2019/02/12/matching-tracts-to-cities-using-r/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mattle24.github.io/mattle24_blog/public/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mattle24.github.io/mattle24_blog/public/" accesskey="h" title="Blog (Alt + H)">Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mattle24.github.io/mattle24_blog/public/" title="All Posts">
                    <span>All Posts</span>
                </a>
            </li>
            <li>
                <a href="https://mattle24.github.io" title="Home">
                    <span>Home</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Matching Tracts to Cities using R
    </h1>
    <div class="post-meta">February 12, 2019&nbsp;·&nbsp;Matt Lehman
</div>
  </header> 
  <div class="post-content">


<p>This blog post is focused on how to match data from US Census tracts to US Census Places (cities) without a crosswalk table. Matching tract data to places may be useful for a variety of reasons. Recently, I wanted to measure segregation in US cities for a research project. The most commonly used metric is the <a href="https://www.census.gov/hhes/www/housing/resseg/pdf/app_b.pdf">dissimilarity index</a>, which measures how much of the minority population would have to move neighborhoods in order for the overall metropolitan area to be evenely integrated.</p>
<p>However, the dissimilarity index requires matching sub-geomtries (neighborhoods) to macro geometries (places). I could not find any crosswalk table to link Census tracts, accepted as proxies for neighborhoods <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, to places in 1970. For a while, I wrote off the task as impratically difficult.</p>
<p>As is often the case, all it took was learning about the right package. The <a href="https://github.com/r-spatial/sf"><code>sf</code></a> package provided me with all of the tools I needed to match tracts to places. In my research, I use data from <a href="nhgis.org">IMPUS NHGIS</a>, which has been an invaluable resource. However, to keep this example easily accessible, I will instead use tract data from the American Community Survey via <a href="https://github.com/walkerke/tidycensus"><code>tidycensus</code></a> and place boundaries from <a href="https://github.com/walkerke/tigris"><code>tigris</code></a>. Using <code>tidycensus</code> does require requesting a free API key from the US Census, which you can do <a href="https://api.census.gov/data/key_signup.html">here</a>.</p>
<div id="packages-and-setup" class="section level2">
<h2>Packages and setup</h2>
<pre class="r"><code>library(sf)
library(ggplot2)
library(dplyr)
library(tidycensus)
library(tigris)
library(tidyr)</code></pre>
<pre class="r"><code>Sys.getenv(&quot;CENSUS_API_KEY&quot;) # load API key from .Renviron
options(tigris_class = &quot;sf&quot;)
ggplot2::theme_set(theme_bw() + theme(rect = element_blank()))</code></pre>
</div>
<div id="obtain-and-munge-data" class="section level2">
<h2>Obtain and munge data</h2>
<pre class="r"><code># get tract level ACS data with white and African American population
ind_tracts &lt;- tidycensus::get_acs(state = &quot;IN&quot;, geography = &quot;tract&quot;, 
                  variables = c(&quot;B02001_002E&quot;, &quot;B02001_003E&quot;), geometry = TRUE)

ind_places &lt;- tigris::places(&quot;IN&quot;)</code></pre>
<p>The tracts are in tidy format, with one row for variable <code>B02001_002E</code> (population white) and another row for <code>B02001_003E</code> (population black/ African American) but I wanted both variables in one row per tract.</p>
<pre class="r"><code>ind_tracts &lt;- ind_tracts %&gt;% 
  select(-moe) %&gt;% 
  spread(key = variable, value = estimate) %&gt;% 
  rename(white_pop = B02001_002, black_pop = B02001_003)</code></pre>
</div>
<div id="geo-analysis" class="section level2">
<h2>Geo-analysis</h2>
<p>To simplify the example, I isolated one city to see how tracts and places match. Since my research is focused on Indianapolis, I used that as the example. To start, I mapped Indianapolis by itself to get a sense of what to expect.</p>
<pre class="r"><code>indianapolis &lt;- ind_places %&gt;% 
  filter(NAME == &quot;Indianapolis city (balance)&quot;)

ggplot(indianapolis) +
  geom_sf(color = &quot;darkblue&quot;, fill = &quot;skyblue&quot;) +
  coord_sf(datum = NA) +
  theme(plot.title = element_text(hjust = 0.5)) +
  labs(title = &quot;Indianapolis&quot;)</code></pre>
<p><img src="/mattle24_blog/public/post/tracts_to_places_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>Now, let’s match the tracts. First, I tried <code>st_covers()</code> (a helpful <a href="https://github.com/rstudio/cheatsheets/blob/master/sf.pdf"><code>sf</code> cheatsheet is available</a> for these functions).</p>
<pre class="r"><code># get a matrix of one row with a logical column for each tract, TRUE if Indianapolis covers it
covers_matrix &lt;- st_covers(indianapolis, ind_tracts, sparse = FALSE)
dim(covers_matrix)

# map out the tracts with Indianapolis
ggplot(indianapolis) +
  geom_sf(color = &quot;darkblue&quot;, fill = &quot;skyblue&quot;) +
  geom_sf(data = ind_tracts[t(covers_matrix), ], color = &quot;yellow&quot;, fill = &quot;yellow&quot;, alpha = 0.2) +
  coord_sf(datum = NA)</code></pre>
<p><img src="/mattle24_blog/public/post/tracts_to_places_files/figure-html/st_covers-1.png" width="672" /></p>
<p><code>st_covers()</code> did an okay job, but I was missing all of the tracts with any area outside of Indianapolis. Next, I tried <code>st_intersects()</code>.</p>
<pre class="r"><code># get a matrix of one row with a logical column for each tract, TRUE if it intersects Indianapolis
intersects_matrix &lt;- st_intersects(indianapolis, ind_tracts, sparse = FALSE)
dim(intersects_matrix)

# map out the tracts with Indianapolis
ggplot(indianapolis) +
  geom_sf(color = &quot;darkblue&quot;, fill = &quot;skyblue&quot;) +
  geom_sf(data = ind_tracts[t(intersects_matrix), ], color = &quot;yellow&quot;, fill = &quot;yellow&quot;, alpha = 0.2) +
  coord_sf(datum = NA)</code></pre>
<p><img src="/mattle24_blog/public/post/tracts_to_places_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p><code>st_intersects()</code> was better, but still problematic. It picked up all of the tracts inside of Indianapolis, but also all of the tracts bordering Indianapolis. To rememedy this, I used <code>st_intersection()</code>. To simplify, I’m going to use the subset of the tracts defined by <code>st_intersects()</code> instead of the full <code>ind_tracts</code>.</p>
<pre class="r"><code># get a matrix of one row with a logical column for each tract, TRUE if it intersects Indianapolis
ind_tracts_intersection &lt;- st_intersection(indianapolis, ind_tracts[t(intersects_matrix), ])</code></pre>
<pre><code>## Warning: attribute variables are assumed to be spatially constant
## throughout all geometries</code></pre>
<pre class="r"><code># map out the tracts with Indianapolis
ggplot(indianapolis) +
  geom_sf(color = &quot;darkblue&quot;, fill = &quot;skyblue&quot;) +
  geom_sf(data = ind_tracts_intersection, color = &quot;yellow&quot;, fill = &quot;yellow&quot;, alpha = 0.2) +
  coord_sf(datum = NA)</code></pre>
<p><img src="/mattle24_blog/public/post/tracts_to_places_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>Unlike the previous two functions, <code>st_intersection()</code> returns an <code>sf</code> object. The function seems to essentially trim the tracts to make sure they are within Indianapolis. However, the new <code>sf</code> object contains all of the tracts as the <code>sf</code> object indexed by <code>intersects_matrix</code>, including the ones that lo longer have any significant area.</p>
<pre class="r"><code>nrow(ind_tracts_intersection) == nrow(ind_tracts[t(intersects_matrix), ])</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>My hacky solution was to look at the areas. In the trimmed <code>sf</code> object, the borderline tracts have area approximately 0% of their original area. I confirmed this by plotting the trimmed tracts with less than 1% of their original area.</p>
<pre class="r"><code>pcts &lt;- as.numeric(st_area(ind_tracts_intersection)) / as.numeric(st_area(ind_tracts[t(intersects_matrix), ]))
x &lt;- pcts &lt; 0.01

ggplot(indianapolis) +
  geom_sf(color = &quot;darkblue&quot;, fill = &quot;skyblue&quot;) +
  geom_sf(data = ind_tracts[t(intersects_matrix), ][x, ], color = &quot;yellow&quot;, fill = &quot;yellow&quot;, alpha = 0.2) +
  coord_sf(datum = NA) </code></pre>
<p><img src="/mattle24_blog/public/post/tracts_to_places_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
</div>
<div id="calculating-the-dissimilarity-index" class="section level2">
<h2>Calculating the dissimilarity index</h2>
<p>Using the percents as weights (or filtering out tracts with very small percentages), I could calculate the dissimilarity index. For Indianapolis, it does not matter if I filtered out &lt; 1% or just used percents as weights. This analysis does have the assumption that tract population is evenly spread out among the tract, but do not think the assumption has much of an impact on the index since the weights of areas I did not want to include are so low.</p>
<pre class="r"><code># Calculate the disimilarity index (di) given a set of sub-geometries that match a macro-level geometry. 
# Eg. all the tracts in a place.
dissimilarity_index &lt;- function(sub_geometry, majority_pop = white_pop, minority_pop = black_pop) {
  majority_pop &lt;- enquo(majority_pop)
  minority_pop &lt;- enquo(minority_pop)
  st_geometry(sub_geometry) &lt;- NULL # make it a df 
  
  sub_geometry %&gt;%
    mutate(
      t =  !!majority_pop + !!minority_pop # pop in subgeometry
      ,p = !!minority_pop / t # prop minority in tract
    ) %&gt;% 
    summarise(
      T. = sum(wt * t) # total pop in macro geometry
      ,P. = sum(wt * !!minority_pop) / T. # prop minority in macro geometry
      ,dissimilarity_index = sum(wt * t * abs(p - P.)) / (2 * T. * P. * (1 - P.))
      ) %&gt;% 
    .$dissimilarity_index
}

ind_tracts_intersection$wt &lt;- pcts
dissimilarity_index(ind_tracts_intersection)</code></pre>
<pre><code>## [1] 0.5294555</code></pre>
<pre class="r"><code>ind_tracts_intersection$wt[ind_tracts_intersection$wt &lt; 0.01] &lt;- 0
dissimilarity_index(ind_tracts_intersection)</code></pre>
<pre><code>## [1] 0.5294455</code></pre>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Massey, Douglas, and Nancy Denton. 1998. American Apartheid: Segregation and the Making of the Underclass. Cambridge, MA: Harvard University Press. <a href="https://scholar.google.com/scholar_lookup?hl=en&amp;publication_year=1998&amp;author=Douglas+Massey&amp;author=Nancy+Denton&amp;title=American+Apartheid%3A+Segregation+and+the+Making+of+the+Underclass">Google Scholar</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</div>


  </div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mattle24.github.io/mattle24_blog/public/tags/sf/">sf</a></li>
      <li><a href="https://mattle24.github.io/mattle24_blog/public/tags/spatial-data/">spatial data</a></li>
      <li><a href="https://mattle24.github.io/mattle24_blog/public/tags/us-census/">us census</a></li>
      <li><a href="https://mattle24.github.io/mattle24_blog/public/tags/tracts/">tracts</a></li>
      <li><a href="https://mattle24.github.io/mattle24_blog/public/tags/dissimilarity-index/">dissimilarity index</a></li>
      <li><a href="https://mattle24.github.io/mattle24_blog/public/tags/r/">r</a></li>
      <li><a href="https://mattle24.github.io/mattle24_blog/public/tags/rstats/">rstats</a></li>
      <li><a href="https://mattle24.github.io/mattle24_blog/public/tags/data-science/">data science</a></li>
    </ul>
  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://mattle24.github.io/mattle24_blog/public/">Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
